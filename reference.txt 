Common usage of syscall:
syscall 0: return 0 -> use with jr $ra
syscall 1: print int
        -> li   $v0, 1
        -> move $a0, (register)
        -> syscall
syscall 4: print string
syscall 5: scan int
        -> li   $v0, 5
        -> syscall
        -> move (other register), $v0
syscall 11: scan char
        -> li   $v0, 11
        -> li   $v0, '*'
        -> syscall



Usage of array:
- declare array: ARRAY_LEN = 10(at the .text)
- assign value (at the .data): 
numbers:
    .word   0:ARRAY_LEN         # int numbers[ARRAY_LEN] = {0};

lw: loads a word from memory(address) into a register. i.e comparing elements of the array.

    mul     $t1, $t0, 4         # element address = i * 4
    li      $t2, numbers        # start address array numbers[ARRAY_LEN]
    add     $t2, $t1, $t2       # &numbers[i]
    lw      $t4, ($t2)          # int x = numbers[i];

    OR

    mul	$t1, $t0, 4			    #   &numbers[i] = numbers + 4 * i -> given numbers: .space 4 * ARRAY_LEN			# int numbers[ARRAY_LEN];
	sw	$v0, numbers($t1)		#   numbers[i] = x

    OR      

    lb      $t2, prime($t0)     # to get prime[i($t0)] only if the prime array is sizeof(char), so no need to use formula to * 4. 

sw: Stores a word from a register into the array of memory.i.e reading integers from array

    mul     $t1, $t0, 4         # element address = i * 4
    li      $t2, numbers        # start address array numbers[ARRAY_LEN]
    add     $t2, $t1, $t2       # &numbers[i]
    sw      $v0, ($t2)          # scanf("%d", &numbers[i]);

    OR

    li      $v0, 1
    mul	    $t1, $t0, 4			#   
	lw	    $a0, numbers($t1)   # &numbers[i] = numbers + 4 * i
    syscall					    # printf("%d", numbers[i])

    OR

    sw	    $t5, ($t2)			# numbers[i] = y;

### [i - 1] in int array: -> &numbers[i] - 4
    addi    (new register), (i register), (-4)

### 2d array:
- calculate a row of array: number of element * size
- then add with the address of column
- make its sum mul with the sizeof(int, char, double...)
- use lw to assign the value from address into register

    mul     $t2, $t0, N_COLS    # offset = x(row) * 24
    add     $t2, $t2, $t1       # offset + y(col)
    mul     $t2, $t2, 4         # (offset + y) * sizeof(int)
    lw      $a0, array($t2)     # &array[x][y] = array + (x * N_COLS + y) * sizeof(int)



Useage of Function:
    prologue:
        begin
        push    $ra
        push    $other s register

    epilogue:
        pop     $other s register
        pop     $ra
        end
        jr      $ra (if main, before it plus li $v0 0 )

### Use jal to call a function: 
- the return of a function stores at $v0, use move to copy this value to other register. 
- the argument of a function i.e rand(sum) is represented by $a0, $a1... before jal function, you need to assign the 'a' register

    li      $a0, 100        # $a0 = 100
    jal     rand            # rand(100);
    move    $s0, $v0        # int value = rand(100)

    OR

    move    $a0, $s0        # move value to a register
    jal     sub_rand        # sub_rand(value)
    move    $s0, $v0        # value = sub_rand(value)
