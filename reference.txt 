Common usage of syscall:
syscall 0: return 0 -> use with jr $ra
syscall 1: print int
        -> li   $v0, 1
        -> move $a0, (register)
        -> syscall
syscall 4: print string
syscall 5: scan int
        -> li   $v0, 5
        -> syscall
        -> move (other register), $v0
syscall 11: scan char
        -> li   $v0, 11
        -> li   $v0, '*'
        -> syscall

Usage of array:
- declare array: ARRAY_LEN = 10(at the .text)
- assign value (at the .data): 
numbers:
    .word   0:ARRAY_LEN         # int numbers[ARRAY_LEN] = {0};

lw:Loads a word from memory(address) into a register. i.e comparing elements of the array.

    mul     $t1, $t0, 4         # element address = i * 4
    li      $t2, numbers        # start address array numbers[ARRAY_LEN]
    add     $t2, $t1, $t2       # &numbers[i]
    lw      $t4, ($t2)          # int x = numbers[i];

sw: Stores a word from a register into the array of memory.i.e reading integers from array

    mul     $t1, $t0, 4         # element address = i * 4
    li      $t2, numbers        # start address array numbers[ARRAY_LEN]
    add     $t2, $t1, $t2       # &numbers[i]
    sw      $v0, ($t2)          # scanf("%d", &numbers[i]);

    OR

    sw	    $t5, ($t2)			# numbers[i] = y;

### [i - 1] in int array: -> &numbers[i] - 4
    addi    (new register), (i register), (-4)

### 2d array:
- calculate a row of array: number of element * size
- then add with the address of column
- make its sum mul with the sizeof(int, char, double...)
- use lw to assign the value from address into register

    mul     $t2, $t0, N_COLS    # offset = x(row) * 24
    add     $t2, $t2, $t1       # offset + y(col)
    mul     $t2, $t2, 4         # (offset + y) * sizeof(int)
    lw      $a0, array($t2)     # &array[x][y] = array + (x * N_COLS + y) * sizeof(int)
